#pragma once

/*
Реализирайте клас Schedule, който реализира дневен график. Той съхранява задачи, като за всяка се знае и време, в което се очаква да започне (с точност до минута). Не се допуска две задачи да започват в едно и също време. Има също и име – символен низ с произволна дължина (например „Sunday cleaning plan”).
    - Реализирайте нужните ви методи за осигуряване на коректен жизнен цикъл на обект от този клас.
    - Дефинирайте метод, чрез който към даден график се добавя задача. Освен задачата, този метод трябва да получава като аргумент в кой час и минута се планира да започне тя. За да се осъществи добавяне, трябва да са изпълнени следните условия:
        - задачата да приключва в рамките на деня (например не може да започне в 23:30, ако продължителността ѝ е повече от 30 мин.)
        - ако се застъпва с вече съхранена една или повече задачи, то трябва всички те да са с по-малък приоритет. Тогава новата задача се запазва, а по-ниско приоритетните задачи се премахват от графика. Ако се застъпва с поне една по-приоритетна (според горната дефиниция) задача, то календарът да остава непроменен.

За класа Schedule дефинирайте още следните методи:
    - метод, който по подаден час (без минути), извежда на екрана всички незавършени задачи, попадащи изцяло или частично в 60-те минути на този час, подредени по началното си време;
    - метод, който по зададен час и минута връща връзка към най-приоритетната задача, планирана да се изпълнява в този момент;
    - метод за съхранение на данните от един такъв обект в текстов файл, както и метод за прочитане на така записан обект.
*/
#include "task.hpp"

class Schedule {

public:
    Schedule(const char* name = "");

    Schedule(const Schedule& other);
    Schedule& operator=(const Schedule& other);

    Schedule(Schedule&& other) noexcept;
    Schedule& operator=(Schedule&& other) noexcept;

    ~Schedule() noexcept;

    bool add(Task& task, uint16_t hour, uint16_t minute);

    bool printTasksInHourInterval(uint16_t hour);
    Task* getTaskWithMostPriorityNow(uint16_t hour, uint16_t minute) const { return tasks[hour * 60 + minute]; }

    static Schedule deserialize(std::istream& is);
    static bool serialize(const Schedule& schedule, std::ostream& os);

private:
    char* name;
    Task** tasks;

    static const uint32_t maxTasks;
    static const char nullRead;
    static const char pointerRead;
};